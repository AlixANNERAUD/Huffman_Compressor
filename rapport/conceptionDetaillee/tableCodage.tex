\section{Table de codage}

\begin{algorithme}

    \begin {enregistrement}{codingTable}
    \champEnregistrement{table}{\tableau{0..255, 0..1}{de}{\binaryCode}}
    \commentaire{La ligne 0 de table donne les codes binaires associés aux bytes stockés dans la ligne 1.}
    \champEnregistrement{size}{[0..255]}
    \end{enregistrement}
    \espace
    \fonction{codingTable}{}{\codingTable}{}
    {codingTable : \codingTable}
    {
        \affecter {codingTable.size}{0}
        \retourner {codingTable}
    }
    \espace
    \procedure{add}{\paramEntreeSortie{codingTable : \codingTable}, \paramEntree{byte : \byte}, \paramEntree{binaryCode : \binaryCode}}
    {add(table, byte, binaryCode): non(isPresent(codingTable, byte))}
    {}
    {
        \affecter {codingTable[codingTable.size+1][0]}{binaryCode}
        \affecter {codingTable[codingTable.size+1][1]}{byte}
        \affecter {codingTable.size}{codingTable.size+1}
    }
    \espace
    \fonction{getCode}{codingTable : \codingTable, byte : \byte}{\binaryCode}
    {getCode(table, byte): isPresent(table, byte)}
    {i : \naturel}
    {
        \affecter{i}{0}
        \tantque{codingTable[i][1] $\ne$ byte}{
            \affecter {i}{i+1}
        }
        \retourner {codingTable[i]}
    }
    \espace
    \fonction{isPresent}{codingTable : \codingTable, byte : \byte}{\booleen}{}
    {i : \naturel}
    {
        \affecter{i}{0}
        \tantque{codingTable[i][1] $\ne$ byte et i < codingTable.size}{
            \affecter {i}{i+1}
        }
        \retourner {codingTable[i][1] = byte}
        \commentaire {On vérifie qu'on a bien trouvé byte, et que l'arrêt de la boucle n'est pas parce qu'on a parcouru entièrement le tableau}
    }

\end{algorithme}