\section{File de priorité}

En informatique, une file est un type abstrait de données permettant le stockage et l'accès à des données selon le principe du premier entré, premier sorti (FIFO).
Dans notre cas, ce principe n'est respecté que partiellement, car ce sont bien les élément en tête de file qui sont retirés en premier.
Cependant, l'ajout d'un élément se fait ici en fonction de son poids et de son rang dans la table ASCII en cas d'égalité.

\newcommand{\priorityQueue}{\textbf{PriorityQueue}}

\begin{tad}
    \tadNom{\priorityQueue}
    \tadParametres{Element}
    \tadDependances{\naturel}
    \begin{tadOperations}{push}
        \tadOperation{priorityQueue}{}{\tadParams{\priorityQueue}}
        \tadOperation{get\_length}{\tadParams{\priorityQueue}}{\naturel}
        \tadOperationAvecPreconditions{pop}{\tadParams{\priorityQueue}}{\tadParams{\priorityQueue, Element}}
        \tadOperationAvecPreconditions{push}{\tadParams{\priorityQueue, Element}}{\tadParams{\priorityQueue}}
    \end{tadOperations}
    \begin{tadSemantiques}{insert}
        \tadSemantique{priorityQueue}{Crée une file de priorité vide.}
        \tadSemantique{get\_length}{Renvoi la taille de la file de priorité.}
        \tadSemantique{pop}{Renvoi puis supprime l'élément situé en tête de file.}
        \tadSemantique{push}{Insère un élément dans la file de priorité en respectant l'ordre de priorité (poids puis ordre ascii en cas d'égalité).}
    \end{tadSemantiques}
    \begin{tadAxiomes}
        \tadAxiome{get\_length(insert(queue, tree)) = get\_length(queue) + 1}
        \tadAxiome{pop(insert(queue, tree)) = tree}
    \end{tadAxiomes}
    \begin{tadPreconditions}{insert(queue, element)}
        \tadPrecondition{pop(queue)}{get\_length(queue) > 0}
        \tadPrecondition{push(queue, element)}{get\_length(queue) < MAXIMUM\_LENGTH}
    \end{tadPreconditions}
\end{tad}